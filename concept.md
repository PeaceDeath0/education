# Структуры данных C++: list, stack, map 
## _Конспект_
# List 

Это структура данных, которая построена на двусвязных списках. Это значит, что любой элемент знает только о предыдущем и о следующем элементах.

На картинке ниже показана, как это устроено:
как работает list в C++
![List](https://codelessons.dev/static/a07295ec394cb7a7e3127c500341fc10/c2945/Безымянный-4-1.webp)

У двусвязного списка нет индексов, но вместо их в C++ есть итераторы.

```c
i_am_list[2] = 8;  // ошибка!
```

Программисты используют этот контейнер из-за быстрого добавления и удаление значений. Это происходит так быстро, потому что не приходиться перемещать элементы между собой, нужно лишь правильно манипулировать указателями.
![l](https://codelessons.dev/static/44feb9471ac7aadc0c88ae1dff4cdb1c/c2945/1-2.webp)
![D](https://codelessons.dev/static/c797aca4ece42cb626f4f28f7947a572/3aa79/2-1-1.webp)

На примере выше в начале было два элемента, потом мы решили добавить один элемент между ними.

### Как создать список list
Сначала подключаем библиотеку - ```<list> ```.
```c
#include <list>
```
Далее используем конструкцию ниже:
```c
list <тип данных> <имя контейнера>;
```
* < тип данных > - сюда мы должны указать тип, который хотим использовать.
* <имя контейнера> - это будет нашим именем контейнера. Лучше указывать такое имя, которое будет говорить, за что этот контейнер отвечает.

Вот пример создания списка с типом string:
```c
list <string> listok;
```
### Как добавить элементы при создании списка
Чтобы сразу после создания списка присвоить ему значения нужно сделать так:
```c
list <int> this_list = {4, 6, 3, 2};
```
|Такой способ можно использовать только в C++ 11 и выше.|
|-|
### Методы списка list

Вот функции которые можно применять в своей программе вместе со списком:

|Метод|Функция|
|:-:|:-:|
|pop_front|удалить элемент в начале|
|pop_back|удалить элемент в конце|
|push_front|добавить элемент в начала|
|push_back|добавить элемент в конец|
|front|обратится к первому элементу|
|back|обратиться к последнему элементу| 
|insert|добавить элемент в какое-то место|
|copy|вывести все элементы списка (и не только)| |unique|удалить все дубликаты|
|merge|добавление другого списка|

### insert
С помощью его можно добавить новый элемент в любую часть контейнера (в нашем случае для списка). Вот как он работает:
```c
insert (<позиция>, <значение>);
```
* Первым аргументом передаем - местоположение. Оно указывается итератором, что это читайте вот здесь.
* Вторым значение новой ячейки. Здесь может быть как переменная так и просто значение (5 например).
```c
string cpp = "Это легко";
insert (it, cpp);
```

### copy

Вообще он имеет несколько видов применения:

* Вывод элементов.
* Запись элементов.
* А также копирования какого-то количества ячеек и вставка их в позицию Y.

Чтобы его использовать дополнительно нужно подключить библиотеку -``` <iterator>```.

```c
copy(my_list.begin(), my_list.end(), ostream_iterator<int>(cout," "));
```
Первые два значения ``` (my_list.begin(), my_list.end()) ``` которые должны передать, - это итераторы начала и конца контейнера.

Дальше используем итератор вывода -``` ostream_iterator<int>(cout," ")```. В кавычках указывается значение между элементами (в нашем случае это пробел).
### unique
Удаляет все повторяющиеся элементы (дубликаты). Использовать его очень просто:
```c
my_list.unique();
```

### merge
Добавляет существующему списку еще один.
```c
my_list.merge(dob_spisok);
```

Вот пример кода с использованием выше приведенных методов:
```c
#include <iostream>
#include <list>
#include <iterator>

using namespace std;

int main() {
  list <int> my_list;
  list <int> list_merge = {7, 8, 9};

  for (int i = 0; i < 2; i++) {
    for (int j = 1; j < 6; j++) {
      my_list.push_back(i); // добавили 10 элементов
    }
  }

  copy (my_list.begin(), my_list.end(), ostream_iterator(cout, " ")); 
  cout << endl;                                                

  my_list.insert(my_list.end(), 6);  // добавили новый элемент

  copy (my_list.begin(), my_list.end(), ostream_iterator(cout, " "));  
  cout << endl;
  
  my_list.unique();  // удалили все дубликаты
  list <int> :: iterator it; 

  for (it = my_list.begin(); it != my_list.end(); it++) { 
    cout << (*it) << " ";
  }

  my_list.merge(list_merge);  // присвоили список 
  for (it = my_list.begin(); it != my_list.end(); it++) {
    cout << (*it) << " ";  
  }
  return 0;
}
```

## Что такое Map

Это ассоциативный контейнер, который работает по принципу - [ключ - значение]. Он схож по своему применению с вектором и массивом, но есть некоторые различия:

1. Ключом может быть все что угодно. От обычной переменной до класса.
```c
mp1[0] = 7; // ключ - число

mp2["zero"] = 4;  // ключ - строка

pair <int, int> p = make_pair(1, 3);
mp3[p] = 3;  // ключ - пара
```
2. При добавлении нового элемента контейнер будет отсортирован по возрастанию.

Когда нужно найти наиболее простое обьяснение как работает Map, можно привести эту картинку:

![v](https://codelessons.dev/static/3b8d3c804ff5ab7b93a315e07e5e8b87/e88ff/map-ключ.webp)

|Мы можем создать ключ из любых компонентов и он будет - рабочим.|
|-|

Поэтому можно с легкостью сделать словарь:

* Ключом в нашем случае будет - русское слово.
* А значением - английское.
```c
map <string, string> mp;
mp["привет"] = "hi";
```
### Как создать map
Сперва понадобится подключить соответствующую библиотеку:
```c
#include <map>
```
Чтобы создать map нужно воспользоваться данной конструкцией:
```c
map < <L>, <R> > <имя>;
```
* ``` <L> ``` - этот тип данных будет относиться к значению ключа.
* ``` <R> ``` - этот тип данных соответственно относится к значению.
```c
map <string, int> mp; // пример
```
В нашем случае:

* Ключ - строка.
* Значение - число.

|При создании map все его элементы будут иметь значение нуля.|
|-|

Также имеется возможность добавить значения при инициализации (C++ 11 и выше):
```c
map <string, string> book = {{"Hi", "Привет"},
                             {"Student", "Студент"},
                             {"!", "!"}};

cout << book["Hi"];
```
### Итераторы для map
Использование итераторов одна из главных тем, если вам понадобится оперировать с этим контейнером. Создание итератора, как обычно происходит так:
```c
map <тип данных> :: iterator <имя>;
<тип данных> - <string, int> например.
```
С помощью его можно использовать две операции (```it ```- итератор):
1. Чтобы обратится к ключу нужно сделать так: it->first.
2. Чтобы обратится к значению ячейки нужно сделать так: it->second.

|Нельзя обращением к ключу (```...->first ```) изменять его значение, а вот изменять таким образом значение ячейки (``` ...->second```) легко.|
|-|
Нельзя использовать никакие арифметические операции над итератором:
```c
it *= 5;

it += 3;

it /= 10;
```
Все это будет считаться еще одной ошибкой для компилятора.
Для увеличения или уменьшения можно использовать инкремент или декремент.
```c
it++;
it--;
```
|Нельзя делать то же самое используя операцию присваивания (```it += 1```) или вычитания (```it -= 1```).|
|-|

Чтобы не писать циклы для увеличения итератора на большие значения, можно воспользоваться функцией ```c advance()```:
```c
advance(it, 7);
advance(it, -5);
```
Она сдвигает указанный итератор вниз или вверх на указанное количество ячеек. В нашем случае он сначала увеличит на 7, а потом уменьшит на 5, в итоге получится сдвиг на две вверх.
### Вывод контейнера
Давайте попробуем вывести все элементы, которые находятся в контейнере.
```c
#include <iostream>
#include <map>

using namespace std;
int main() {
    setlocale(0, "");
    map <int, int> mp;
    
    cout << "Введите количество элементов: "; int n; cin >> n;

    for (int i = 0; i < n; i++) {
        cout << i << ") "; int a; cin >> a;
        mp[a] = i;  // добавляем новые элементы
    }

    map <int, int> :: iterator it = mp.begin();
    cout << "А вот все отсортированно: " << endl;
    for (int i = 0; it != mp.end(); it++, i++) {  // выводим их
        cout << i << ") Ключ " << it->first << ", значение " << it->second << endl;
    }
    
    system("pause");
    return 0;
}
```
А вот рабочая программа:
```
Введите количество элементов: 5
0) 33
1) 5
2) 2
3) 9
4) 27
А вот все отсортированно:
0) Ключ 2, значение 2
1) Ключ 5, значение 1
2) Ключ 9, значение 3
3) Ключ 27, значение 4
4) Ключ 33, значение 0
Process returned 0 (0x0) execution time : 0.010 s
Press any key to continue.
```
### Методы map
Ниже мы разберем функции которые можно использовать для работы с map.
* insert
* count
* find
* erase

|Некоторые функции не могут работать с map из-за его специфической архитектуры.|
|-|
### insert
Это функция вставки нового элемента.
```c
mp.insert(make_pair(num_1, num_2));
```
* ```num_1 ```- ключ.
* ```num_2 ``` - значение.

Мы можем сделать то же самое вот так:
```c
mp[num_1] = num_2;
```
### count
Возвращает количество элементов с данным ключом. В нашем случае будет возвращать - 1 или 0.
|Эта функция больше подходит для multimap, у которого таких значений может быть много.|
|-|
```c
mp[0] = 0;
    
mp.count(0); // 1
mp.count(3); // 0
```
Нужно помнить, что для строк нужно добавлять кавычки - ```count("Good")```.

### find
У этой функции основная цель узнать, есть ли определенный ключ в контейнере.

* Если он есть, то передать итератор на его местоположение.
* Если его нет, то передать итератор на конец контейнера.

Например, давайте разберем данный код:
```c
#include <iostream>
#include <map>  // подключили библиотеку

using namespace std;

int main() {
  setlocale(0, "");
  map <string, string> book;  
  book["book"] = "книга";     

  map <string, string> :: iterator it, it_2;

  it = book.find("book");
  cout << it->second << endl;

  it_2 = book.find("books");

  if (it_2 == book.end()) {
      cout << "Ключа со значением 'books' нет";
  }

  system("pause");
  return 0;
}
```
Давайте рассмотрим поподробнее:

* В строке 8: мы создали ```map``` под названием - ```book```.
* В строке 9: задали единственный ключ ```"book"``` со значением ```"книга"```.
* В строке 11: создали два итератора ```it и it_2```.
* В строке 13 - 14: получаем итератор на ключ “book” и выводим его значение.
* В строке 16: получаем итератор на ключ “books”, которого нет в нашем контейнере.
* В строке 18 - 20: проверяем не указывает ли it_2 на конец контейнера и предупреждаем пользователя.

###erase

Иногда приходится удалять элементы. Для этого у нас есть функция - ```erase()```.

Давайте посмотрим как она работает на примере:
```c
map <string, string> passport;

passport["maxim"] = "Denisov";     // добавляем
passport["andrey"] = "Puzerevsky"; // новые
passport["dima"] = "Tilyupo";      // значения

cout << "Size: " << passport.size() << endl;

map <string, string> :: iterator full_name; // создали итератор на passport

full_name = passport.find("andrey"); // находим ячейку
passport.erase(full_name);           // удаляем

cout << "Size: " << passport.size();
```
```passport``` в нашем случае хранит имя как ключ, а фамилию как значение.

В итоге мы уменьшим количество наших элементов на один.

|Также здесь мы воспользовались функцией ```size()```, которая возвращает количество элементов.|
|-|

А вот вывод:
```
Size: 3
Size: 2

Process returned 0 (0x0) execution time : 0.010 s
Press any key to continue.
```
## Что такое стек и как он работает
Стек - это структура данных, которая работает по принципу FILO (first in - last out; первый пришел - последний ушел). В C++ уже есть готовый шаблон - ```stack```.
![s](https://codelessons.dev/static/db4c4fa06bdcd6d5dcf3684cab1599fe/ac387/Безымянный-1.webp)

В стеке элемент, который вошел самый первый - выйдет самым последним. Получается, если вы добавили три элемента в стек первым будет удален последний добавленный элемент.
На рисунке 1 вы можете увидеть 6 чисел: 6, 5, 1, 2, 5, 9. Кстати извлекать их будем в таком же порядке. Например чтобы извлечь число 1 нам придется сначала извлечь числа 6 и 5, а потом уже 1. Так как это стек, эти числа мы добавляли в обратном порядке. Если быть точным вот так: 9, 5, 2, 1, 5, 6.

В стеке нет индексов как в массиве, а значит вы не можете обратиться к определенному элементу. Все потому что, стек построен на связных списках.

Это значит что каждый элемент (кроме последнего - он показывает на NULL, если простыми словами, то на ничего) имеет указатель на следующий элемент. Но есть элемент, на который нет указателя - первый (или как его еще называют головной).

Вы наверно спросите зачем использовать связные списки, если с таким же успехом можно было использовать простой массив. Тем более даже новичку не понадобится много времени чтобы разобраться в нем.

Но все достоинство шаблонного стека заключается в добавлении и удалении элементов. Эти операции происходят за константное время (это хороший плюс).

|стати некоторые программисты делают стек на массивах. О таком способе использования стека мы поговорим чуть позже.|
|-|
### Как создать стек в C++
Для использования шаблона стека в начале нашей программе мы должны подключить библиотеку - ```<stack>```.

Чтобы создать стек нам понадобится оперировать схемой ниже:
```c
stack <тип данных> <имя>;
```
Давайте тщательнее ее разберем:

* С новой строки мы должны написать слова stack.
* ```<тип данных> ```- здесь нам понадобиться написать тот тип данных, который будет храниться в стеке.
* ```<имя> ``` - здесь вам все должно быть понятно.

### Методы стека
Методы - это функции, которые используются для контейнеров типа очереди и стека. Сейчас мы разберем все такие функции на примере ниже:
```c
#include <iostream>
#include <stack>  // подключаем библиотеку для 
                  // использования стека
using namespace std;

int main() {
  setlocale(LC_ALL,"rus");
  stack <int> steck;  // создаем стек

  int i = 0;

  cout << "Введите шесть любых целых чисел: " << endl; // предлагаем пользователю 
                                                      // ввести 6 чисел
  while (i != 6) {
    int a;
    cin >> a; 

    steck.push(a);  // добавляем введенные числа
    i++;
  }
  
  if (steck.empty()) cout << "Стек не пуст";  // проверяем пуст ли стек (нет)

  cout << "Верхний элемент стека: " << steck.top() << endl; // выводим верхний элемент
  cout << "Давайте удалим верхний элемент " << endl;

  steck.pop();  // удаляем верхний элемент

  cout << "А это новый верхний элемент: " << steck.top(); // выводим уже новый
                                                          // верхний элемент 
  system("pause");
  return 0;
}
```
А вот разбор этой программы:

В строке 18: мы добавляем в стек элемент, с помощью функции ```push()```. В скобках должно находиться значение, которое мы хотим добавить.

Кстати, если вы хотите сами создавать вот такие функции у себя в программах (как это делают профессионалы) или хотите узнать как они работают, то обо всем этом вы можете узнать вот здесь.

В строке 22: чтобы проверить пуст ли стек мы воспользовались функцией ```empty()```.

* Если результатом этой функции будет true, то стек чист.
* Если же результатом будет false, то в стеке что-то есть.

В строке 27: была использована функция ```pop()```.Ее используют для удаления верхнего элемента стека.

|В функции ```pop()``` в отличии от функции ```push()``` в скобках не нужно не чего указывать, но сами скобки обязательно должны присутствовать. Так же для функций: ```empty()``` и ```top()```!|
|-|

В строках 24 и 29: мы решили обратиться к верхнему элементу стека, для этого была использована функция - ```top()```.

Давайте посмотрим какой будет результат этой программы при запуске:
```
Введите шесть любых целых чисел:
9 5 2 1 5 6
Верхний элемент стека: 6
Давайте удалим верхний элемент
А это новый верхний элемент: 5
Process returned 0 (0x0) execution time : 0.010 s
Press any key to continue.
```
### Функция peek()
В библиотеку stack добавили новую функцию ```peek()```, с помощью которой вы можете обратиться к ```N``` элементу стека (от вершины).

|Так с помощью этой функции стек начинает напоминать массив.|
|-|

Ниже вы мы использовали функцию ```peek()```, чтобы вывести третий элемент:
```c
  setlocale(LC_ALL,"rus");
  stack <int> steck;

  steck.push(5);   // Добавляем 
  steck.push(1);   // элементы
  steck.push(9);   // в
  steck.push(10);  // стек

  cout << "Третий элемент стека: " << steck.peek(3); // выведет 1
```
|Этой функцией мы можем воспользоваться только в версиях C++ 11 и выше.|
|-|

Функцию ```peek()``` использует маленький круг программистов и надо сразу сказать эта функция не стала столь востребованной, как от нее ожидали создатели.

### Как создать стек с помощью массива
Многие программисты используют не используют шаблон стек, а вместо них оперируют стеками через массивы. Сейчас мы вам покажем как реализовать стек при помощи массива.

Ниже мы создали массив под именем - ```steck``` на 20 элементов, также мы создали переменную ```i``` которая будет указывать на верхний элемент стека.

Для добавления элемента мы будем увеличивать ```i``` на один и в ячейку ```steck[i]``` записывать элемент.

Для удаления элемента мы будем просто уменьшать ```i``` на один.

Как вы наверно уже догадались чтобы обратиться к верхнему элементу стека мы просто обращаемся к ```i``` элементу массива.

|Переменная ```i``` заменила нам функцию ```push()``` и функцию ```top()```.|
|-|

Чтобы посмотреть пуст ли стек мы просто проверяем условие ```i == -1```:

* Если оно true, то стек пуст.
* Если оно false, то в стеке есть какие-то элементы.

Реализация стека с помощью массива находится ниже:
```c
#include <iostream>

using namespace std;

int main() {
  int steck[20];
  int i = -1;  // объявили стек
    
  for (int j = 0; j < 6; j++) {
    int a;
       
    cin >> a;      

    i++;  // увеличиваем i на один
      
    steck[i] = a;  // добавляем в стек элемент
  }
   
  if (i == -1) cout << "Стек пуст";  // проверяем пуст ли стек (нет)
    
  cout << steck[i] << " это верхний элемент стека";
    
  cout << "Сейчас мы удалим верхний элемент";
    
  i--;  // уменьшаем i на один

  system("pause");
  return 0;
}
```
